# ToyIP

一个基于**tun/tap**设备编写的简易的**tcp/ip**协议栈.

这个协议栈只是为了更进一步学习网络编程的一个练习之作.大部分代码参考了[`level-ip`](https://github.com/saminiir/level-ip).

我仔细读完了**level-ip**的实现,发现实现一个协议栈其实并不是很难的一件事情,`arp`, `icmp`,`udp`这些不带任何状态的协议实现起来没有太大难度,当然,**tcp**协议的实现还是很有难度的,它的难度不在于编程的技巧,而是在于复杂性,毕竟它带状态,是一个状态机,而且是`11`种状态,要考虑的情况非常之多.

说到底,不管是**level-ip**还是别的实现,各种协议栈的实现都带有**linux**协议栈的影子,**linux**协议栈好是好,但是为了追求性能放弃了可读性,而且代码过长,并且代码里包含了一些边边角角的东西,犯有一种被称作特性蔓延(creeping featurism)的编程通病,不太适合学习.所以各种简易的实现便层出不穷,事实上,**level-ip**的实现仍然不够简洁,我希望在它的基础上实现一个相对简洁的协议栈.这个协议栈自然不是为了实用,只是为了学习而已.

实现这个东西虽然不是多难的事情,但是还是要花费掉大量的时间的,好处当然有,自打我读实现和写实现以来,我对网络的理解更近了一步,同时对于怎样配置网络,也变得非常熟悉了.更加重要的是,我对于某些网络知识的了解不再只是浮于表面,使用起**linux**的一大堆网络函数也更加得心应手.同时对于**linux**下编程也有了更深的体会.

究竟你有没有必要看一下网络栈的实现,或者自己亲手实现一把协议栈,因人而异吧,不过我个人推荐写网络程序的程序员最好还是了解一下底层的协议会比较好,不然一旦你写的程序出了问题,你甚至会不知道问题出在哪里.




最好的关于协议栈介绍的书籍还是网络之神的那几本大头书,`tcpip`卷详解`1`,卷二的话,可以读一下,然后是`unp`.边写协议栈边读这几本书,收获自然是最大的.


至于如何在你的机器上运行这里的代码,可以参照这里:
1. [http://blog.csdn.net/lishuhuakai/article/details/70305543](http://blog.csdn.net/lishuhuakai/article/details/70305543)
2. [http://blog.csdn.net/lishuhuakai/article/details/70498149](http://blog.csdn.net/lishuhuakai/article/details/70498149)

其余的东西,我已经贴在 `toy_doc` 这个文件夹之内了, 感兴趣的同学可以去看一下.



已经完工的协议有**arp**,**icmp**, **tcp**, **udp**.基本上我想做的一些事情都已经做完了,当然,程序中还存在一些内存问题,一些逻辑问题,这些小 **bug** 需要一步一步来修整.



当然,代码还不够完善,还有许多不常用但是不能少的情况需要编写处理代码,这个暂时我们不管.



还需要进一步补充的功能有**ip**数据包的分片和重组,**tcp**协议的拥塞控制等,但是现在是真没有多少时间来弄了.将来如果需要深入到协议栈这一层的话,继续来将这些东西补充完整吧.至于什么时候,我也不知道.



总之,这个玩意我花了我足足一个多月的大部分时光,终于还是要告一个段落了,接下来的一段时间里,我会写一些博文,来记录以及说明这个协议栈背后的一些东西.

========================================

有时间的话,我要将它改成**cpp**版本,那个时候,代码量会更加少,封装也会更加漂亮.虽然我是这么想的,但是真的抽不出这么多的时间,造一个轮子代价非常昂贵,轻则两三周,重则几个月,在最近一段时间里,真心耗不起.

