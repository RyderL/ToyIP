# TUN/TAP设备浅析

# **TUN**设备

**TUN** 设备是一种虚拟网络设备，通过此设备，程序可以方便地模拟网络行为。**TUN** 模拟的是一个二层设备,也就是说,通过它可以处理来自网络层的数据，所谓的网络层，指的是 **IP** 协议所在的层级。

先来看看物理设备是如何工作的：

![tun设备](./pic/01_TUN.png)

上图中的 **eth0** 表示我们主机已有的真实的网卡接口 (**interface**)。

网卡接口 **eth0** 所代表的真实网卡通过网线(**wire**)和外部网络相连，由该物理网卡收到的数据包会经由接口 **eth0** 传递给内核的网络协议栈(**Network Stack**)。然后协议栈对这些数据进行进一步的处理。

对于一些错误的数据包,协议栈可以选择丢弃；对于不属于本机的数据包，协议栈可以选择转发；而对于确实是传递给本机的数据包,而且该数据包确实被上层的应用所需要，协议栈会通过 **Socket API** 告知该应用,数据到了。



下面看看 **TUN** 的工作方式：

![数据包处理过程](./pic/01_PKT_PROCESS.png)

如果说，普通的网卡是通过网线来收发数据包的话，那么 **TUN** 设备是通过一个文件收发数据包的。

如上图所示，**tunX** 和上面的 **eth0** 在逻辑上面是等价的， **tunX** 也代表了一个网络接口,但是这个接口是系统通过软件所模拟出来的而已.

网卡接口 **tunX **所代表的虚拟网卡通过文件 **/dev/tunX** 与我们的应用程序(**App**) 相连，应用程序每次调用**write**函数对该文件写入的数据，会以网络层数据包的形式，通过该虚拟网卡，经由网络接口 **tunX** 传递给网络协议栈，同时协议栈向 **tunX** 所代表的虚拟网卡传递的数据包，应用程序可以通过 **read**之类的函数经由文件 **/dev/tunX** 读取到。

同时，协议栈可以像操纵普通网卡一样来操纵 **tunX** 所代表的虚拟网卡。比如说，给 **tunX** 设定 **ip** 地址，设置路由，总之，在协议栈看来，**tunX** 所代表的网卡和其他普通的网卡没有任何区别。



如果我们使用 **TUN** 设备搭建一个基于 **UDP**的**VPN**那么整个处理过程就是这样：

![udp vpn](./pic/01_UDP_VPN.png)

首先，我们的应用程序通过真实的网卡 **eth0** 和远程的 **UDP** 程序相连,对方传递过来的 **UDP** 数据包经由左边的协议栈传递给了应用程序，**UDP** 数据包的内容其实是一个网络层的数据包，比如说 **IP** 数据报，应用程序接收到该数据包的数据（剥除了各种头部之后的 **UDP** 数据）之后，然后进行一定的处理，处理完成后将处理后的数据写入文件 **/dev/tunX**，这样，数据会第二次到达协议栈。需要注意的是，上图中的两个协议栈其实是同一个协议栈，之所以这么画是为了叙述方便。

# **TAP**设备

**TAP** 设备与 **TUN** 设备工作方式完全相同，区别在于：

1. **TUN** 设备的 **/dev/tunX** 文件收发的是 **IP** 层数据包，只能工作在 **IP** 层，即网络层，无法与物理网卡做 **bridge**，但是可以通过三层交换（如 **ip_forward**）与物理网卡连通。
2. **TAP** 设备的 **/dev/tapX** 文件收发的是 **MAC** 层数据包，即数据链路层，拥有 **MAC** 层功能，可以与物理网卡做 **bridge**，支持 **MAC** 层广播.

文章摘取自:
[1].  [https://blog.kghost.info/2013/03/27/linux-network-tun/](https://blog.kghost.info/2013/03/27/linux-network-tun/)

